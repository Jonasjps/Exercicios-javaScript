/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview Defines the CSS sanitizer.
 *
 * Note that the CSS sanitizer is performing custom serialization of the CSS
 * string, instead of using `cssText`. The reason for that is twofold:
 *
 * 1. Serialization is not super precisely defined in the CSS spec so we have no
 *    guarantees that it will be stable across browsers and versions.
 * 2. At the moment of writing the sanitizer, a bug in serialization was found
 *    in Chromium. Controlling the serialization ourselves is a way to avoid
 *    that bug and possibly other ones.
 */
import { safeStyleEl } from '../../../dom/index.js';
import { styleSheetSafeByReview } from '../../../restricted/reviewed.js';
import { ResourceUrlPolicyHintsType, parseUrl, } from '../resource_url_policy.js';
import { escapeIdent, serializeTokens } from './serializer.js';
import { tokenizeCss } from './tokenizer.js';
import { CssTokenKind } from './tokens.js';
const INERT_DOCUMENT = document.implementation.createHTMLDocument();
class CssSanitizer {
    constructor(propertyAllowlist, functionAllowlist, resourceUrlPolicy, allowKeyframes, propertyDiscarders) {
        this.propertyAllowlist = propertyAllowlist;
        this.functionAllowlist = functionAllowlist;
        this.resourceUrlPolicy = resourceUrlPolicy;
        this.allowKeyframes = allowKeyframes;
        this.propertyDiscarders = propertyDiscarders;
    }
    getStyleSheet(cssText) {
        const style = INERT_DOCUMENT.createElement('style');
        const safeStyle = styleSheetSafeByReview(cssText, {
            justification: 'Internal safevalues usage',
        });
        safeStyleEl.setTextContent(style, safeStyle);
        INERT_DOCUMENT.head.appendChild(style);
        const sheet = style.sheet; // guaranteed to be non-null
        style.remove();
        return sheet;
    }
    getStyleDeclaration(cssText) {
        const div = INERT_DOCUMENT.createElement('div');
        div.style.cssText = cssText;
        INERT_DOCUMENT.body.appendChild(div);
        const style = div.style;
        div.remove();
        return style;
    }
    hasShadowDomEscapingTokens(token, nextToken) {
        // Thanks to using shadow DOM, the only real worry in selectors are
        // pseudo-classes and pseudo-elements that can be used to target elements
        // outside of the shadow DOM. There are three of them:
        //
        // 1. `:host`
        // 2. `:host()`
        // 3. `:host-context()`
        //
        // We'll disallow all of them.
        if (token.tokenKind !== CssTokenKind.COLON) {
            return false;
        }
        if (nextToken.tokenKind === CssTokenKind.IDENT &&
            nextToken.ident.toLowerCase() === 'host') {
            return true;
        }
        if (nextToken.tokenKind === CssTokenKind.FUNCTION &&
            (nextToken.lowercaseName === 'host' ||
                nextToken.lowercaseName === 'host-context')) {
            return true;
        }
        return false;
    }
    sanitizeSelector(selector) {
        // If we find any tokens we deem insecure in a selector, we'll then treat
        // the whole selector as insecure. In this case, we'll return null;
        // otherwise we'll return the re-serialized tokens.
        const tokens = tokenizeCss(selector);
        for (let i = 0; i < tokens.length - 1; i++) {
            const token = tokens[i];
            const nextToken = tokens[i + 1];
            if (this.hasShadowDomEscapingTokens(token, nextToken)) {
                return null;
            }
        }
        return serializeTokens(tokens);
    }
    sanitizeValue(propertyName, value, calledFromStyleTag) {
        // Values can contain functions, such as url() or rgba(). We maintain
        // an allowlist of functions and we make sure that only those are allowed.
        // Furthermore, a special logic is needed to handle url() functions.
        const tokens = tokenizeCss(value);
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            if (token.tokenKind !== CssTokenKind.FUNCTION) {
                continue;
            }
            // The whole value is disregarded if it contains a disallowed function.
            if (!this.functionAllowlist.has(token.lowercaseName)) {
                return null;
            }
            if (token.lowercaseName === 'url') {
                const nextToken = tokens[i + 1];
                if ((nextToken === null || nextToken === void 0 ? void 0 : nextToken.tokenKind) !== CssTokenKind.STRING) {
                    // Browsers always serialize the first argument of url() as a string.
                    // If this doesn't happen, something weird is going on and we'll
                    // reject the whole value for good measure.
                    return null;
                }
                const url = nextToken.value;
                const sanitizedUrl = this.resourceUrlPolicy(parseUrl(url), {
                    type: calledFromStyleTag
                        ? ResourceUrlPolicyHintsType.STYLE_TAG
                        : ResourceUrlPolicyHintsType.STYLE_ATTRIBUTE,
                    propertyName,
                });
                if (!sanitizedUrl) {
                    return null;
                }
                tokens[i + 1] = {
                    tokenKind: CssTokenKind.STRING,
                    value: sanitizedUrl.toString(),
                };
                // Skip the string token.
                i++;
            }
        }
        return serializeTokens(tokens);
    }
    sanitizeKeyframeRule(rule) {
        const sanitizedProperties = this.sanitizeStyleDeclaration(rule.style, true);
        // It should be safe to just re-use `rule.keyText` here because it can only
        // contain comma-separated percentages.
        //
        // https://drafts.csswg.org/css-animations/#dom-csskeyframerule-keytext
        return `${rule.keyText} { ${sanitizedProperties} }`;
    }
    sanitizeKeyframesRule(keyframesRule) {
        if (!this.allowKeyframes) {
            return null;
        }
        const keyframeRules = [];
        for (const rule of keyframesRule.cssRules) {
            if (!(rule instanceof CSSKeyframeRule)) {
                // The only allowed child rules of CSSKeyframesRule are CSSKeyframeRule.
                continue;
            }
            const sanitizedRule = this.sanitizeKeyframeRule(rule);
            if (sanitizedRule) {
                keyframeRules.push(sanitizedRule);
            }
        }
        return `@keyframes ${escapeIdent(keyframesRule.name)} { ${keyframeRules.join(' ')} }`;
    }
    isPropertyNameAllowed(name) {
        if (!this.propertyAllowlist.has(name)) {
            return false;
        }
        for (const discarder of this.propertyDiscarders) {
            if (discarder(name)) {
                return false;
            }
        }
        return true;
    }
    sanitizeProperty(name, value, isImportant, calledFromStyleTag) {
        if (!this.isPropertyNameAllowed(name)) {
            return null;
        }
        const sanitizedValue = this.sanitizeValue(name, value, calledFromStyleTag);
        if (!sanitizedValue) {
            return null;
        }
        return `${escapeIdent(name)}: ${sanitizedValue}${isImportant ? ' !important' : ''}`;
    }
    sanitizeStyleDeclaration(style, calledFromStyleTag) {
        // We sort the property names to ensure a stable serialization. This also
        // makes the output easier to test.
        const sortedPropertyNames = [...style].sort();
        let sanitizedProperties = '';
        for (const name of sortedPropertyNames) {
            const value = style.getPropertyValue(name);
            const isImportant = style.getPropertyPriority(name) === 'important';
            const sanitizedProperty = this.sanitizeProperty(name, value, isImportant, calledFromStyleTag);
            if (sanitizedProperty) {
                sanitizedProperties += sanitizedProperty + ';';
            }
        }
        return sanitizedProperties;
    }
    sanitizeStyleRule(rule) {
        const selector = this.sanitizeSelector(rule.selectorText);
        if (!selector) {
            return null;
        }
        const sanitizedProperties = this.sanitizeStyleDeclaration(rule.style, true);
        return `${selector} { ${sanitizedProperties} }`;
    }
    sanitizeStyleTag(cssText) {
        const styleSheet = this.getStyleSheet(cssText);
        const rules = styleSheet.cssRules;
        const output = [];
        for (const rule of rules) {
            if (rule instanceof CSSStyleRule) {
                const sanitizedRule = this.sanitizeStyleRule(rule);
                if (sanitizedRule) {
                    output.push(sanitizedRule);
                }
            }
            else if (rule instanceof CSSKeyframesRule) {
                const sanitizedRule = this.sanitizeKeyframesRule(rule);
                if (sanitizedRule) {
                    output.push(sanitizedRule);
                }
            }
        }
        return output.join('\n');
    }
    sanitizeStyleAttribute(cssText) {
        const styleDeclaration = this.getStyleDeclaration(cssText);
        return this.sanitizeStyleDeclaration(styleDeclaration, false);
    }
}
/**
 * Sanitizes a CSS string in a `<style>` tag.
 *
 * @param cssText The CSS string to sanitize.
 * @return The sanitized CSS string.
 */
export function sanitizeStyleTag(cssText, propertyAllowlist, functionAllowlist, resourceUrlPolicy, allowKeyframes, propertyDiscarders) {
    return new CssSanitizer(propertyAllowlist, functionAllowlist, resourceUrlPolicy, allowKeyframes, propertyDiscarders).sanitizeStyleTag(cssText);
}
/**
 * Sanitizes a CSS string in a `style` attribute.
 *
 * @param cssText The CSS string to sanitize.
 * @return The sanitized CSS string.
 */
export function sanitizeStyleAttribute(cssText, propertyAllowlist, functionAllowlist, resourceUrlPolicy, propertyDiscarders) {
    return new CssSanitizer(propertyAllowlist, functionAllowlist, resourceUrlPolicy, false, // allowKeyframes is not relevant for the style attribute
    propertyDiscarders).sanitizeStyleAttribute(cssText);
}
