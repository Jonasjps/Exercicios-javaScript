"use strict";
/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.toAbsoluteResourceUrl = exports.objectUrlFromScript = exports.appendPathSegment = exports.replaceFragment = exports.appendParams = exports.trustedResourceUrl = void 0;
require("../environment/dev.js");
const resource_url_impl_js_1 = require("../internals/resource_url_impl.js");
const script_impl_js_1 = require("../internals/script_impl.js");
const string_literal_js_1 = require("../internals/string_literal.js");
/**
 * Check whether the base url contains a valid origin,
 *
 * A string for an origin must contain only alphanumeric or any of the
 * following: `-.:`, and must not be an IP address. Remember that, as per the
 * documentation for TrustedResourceUrl, the origin must be trustworthy.
 *
 * @param base The base url that contains an origin.
 */
function hasValidOrigin(base) {
    if (!(/^https:\/\//.test(base) || /^\/\//.test(base))) {
        return false;
    }
    const originStart = base.indexOf('//') + 2;
    const originEnd = base.indexOf('/', originStart);
    // If the base url only contains the prefix (e.g. //), or the slash
    // for the origin is right after the prefix (e.g. ///), the origin is
    // missing.
    if (originEnd <= originStart) {
        throw new Error(`Can't interpolate data in a url's origin, ` +
            `Please make sure to fully specify the origin, terminated with '/'.`);
    }
    const origin = base.substring(originStart, originEnd);
    if (!/^[0-9a-z.:-]+$/i.test(origin)) {
        throw new Error('The origin contains unsupported characters.');
    }
    if (!/^[^:]*(:[0-9]+)?$/i.test(origin)) {
        throw new Error('Invalid port number.');
    }
    if (!/(^|\.)[a-z][^.]*$/i.test(origin)) {
        throw new Error('The top-level domain must start with a letter.');
    }
    return true;
}
/**
 * Check whether the base url contains a valid about url at its beginning.
 *
 * An about url is either exactly 'about:blank' or 'about:blank#<str>' where
 * <str> can be an arbitrary string.
 *
 * @param base The base url.
 */
function isValidAboutUrl(base) {
    if (!/^about:blank/.test(base)) {
        return false;
    }
    if (base !== 'about:blank' && !/^about:blank#/.test(base)) {
        throw new Error('The about url is invalid.');
    }
    return true;
}
/**
 * Check whether the base url contains a valid path start at its beginning.
 *
 * A valid path start is either a '/' or a '/' followed by at least one
 * character that is not '/' or '\'.
 *
 * @param base The base url.
 */
function isValidPathStart(base) {
    if (!/^\//.test(base)) {
        return false;
    }
    if (base === '/' ||
        (base.length > 1 && base[1] !== '/' && base[1] !== '\\')) {
        return true;
    }
    throw new Error('The path start in the url is invalid.');
}
/**
 * Check whether the base url contains a valid relative path start at its
 * beginning.
 *
 * A valid relative path start is a non empty string that has no ':', '/' nor
 * '\', and that is followed by a '/'.
 *
 * @param base The base url.
 */
function isValidRelativePathStart(base) {
    // Using the RegExp syntax as the native JS RegExp syntax is not well handled
    // by some downstream bundlers with this regex.
    return new RegExp('^[^:\\s\\\\/]+/').test(base);
}
/**
 * Splits an url into segments using '?' and '#' delimiters.
 *
 * The URL can later be put back together by concatenating the returned segments
 * like: path + params + hash. Note that the delimiters '?' and '#' will
 * already be included in 'params' and 'hash' values respectively when these are
 * not empty.
 *
 * @param url The url to split.
 */
function getUrlSegments(url) {
    const segments = url.split(/\?|#/);
    const params = /\?/.test(url) ? '?' + segments[1] : '';
    const hash = /#/.test(url) ? '#' + (params ? segments[2] : segments[1]) : '';
    return { path: segments[0], params, hash };
}
/**
 * Builds TrustedResourceUrl from a template literal.
 *
 * This factory is a template literal tag function. It should be called with
 * a template literal, with or without embedded expressions. For example,
 *               trustedResourceUrl`//example.com/${bar}`;
 * or
 *               trustedResourceUrl`//example.com`;
 *
 * When this function is called with a template literal without any embedded
 * expressions, the template string may contain anything as the whole URL is
 * a compile-time string constant.
 *
 * When this function is called with a template literal that contains embedded
 * expressions, the template must start with one of the following:
 * - `https://<origin>/`
 * - `//<origin>/`
 * - `/<pathStart>`
 * - `<relativePathStart>/`
 * - `about:blank`
 * - `data:`
 *
 * `<origin>` must contain only alphanumeric or any of the following: `-.:`.
 * Remember that, as per the documentation for TrustedResourceUrl, the origin
 * must be trustworthy. An origin of "example.com" could be set with this
 * method, but would tie the security of your site to the security of
 * example.com. Similarly, formats that potentially cover redirects hosted
 * on a trusted origin are problematic, since that could lead to untrusted
 * origins.
 *
 * `<pathStart>` is either an empty string, or a non empty string that does not
 * start with '/' or '\'.
 * In other words, `/<pathStart>` is either a '/' or a
 * '/' followed by at least one character that is not '/' or '\'.
 *
 * `<relativePathStart> is a non empty string that has no ':', '/' nor '\'.
 *
 * `data:` (data URL) does not allow embedded expressions in the template
 * literal input.
 *
 * All embedded expressions are URL encoded when they are interpolated. Do not
 * embed expressions that are already URL encoded as they will be double encoded
 * by the builder.
 *
 * @param templateObj This contains the literal part of the template literal.
 * @param rest This represents the template's embedded expressions.
 */
function trustedResourceUrl(templateObj, ...rest) {
    // Check if templateObj is actually from a template literal.
    if (process.env.NODE_ENV !== 'production') {
        (0, string_literal_js_1.assertIsTemplateObject)(templateObj, rest.length);
    }
    if (rest.length === 0) {
        return (0, resource_url_impl_js_1.createResourceUrlInternal)(templateObj[0]);
    }
    const base = templateObj[0].toLowerCase();
    if (process.env.NODE_ENV !== 'production') {
        if (/^data:/.test(base)) {
            throw new Error('Data URLs cannot have expressions in the template literal input.');
        }
        if (!hasValidOrigin(base) &&
            !isValidPathStart(base) &&
            !isValidRelativePathStart(base) &&
            !isValidAboutUrl(base)) {
            throw new Error('Trying to interpolate expressions in an unsupported url format.');
        }
    }
    let url = templateObj[0];
    for (let i = 0; i < rest.length; i++) {
        url += encodeURIComponent(rest[i]) + templateObj[i + 1];
    }
    return (0, resource_url_impl_js_1.createResourceUrlInternal)(url);
}
exports.trustedResourceUrl = trustedResourceUrl;
/**
 * Creates a new TrustedResourceUrl with params added to the URL's search
 * parameters.
 *
 * @param params What to add to the URL. Parameters with value `null` or
 * `undefined` are skipped. Both keys and values will be encoded. Do not pass
 * pre-encoded values as this will result them being double encoded. If the
 * value is an array then the same parameter is added for every element in the
 * array.
 */
function appendParams(trustedUrl, params) {
    const urlSegments = getUrlSegments((0, resource_url_impl_js_1.unwrapResourceUrl)(trustedUrl).toString());
    let urlParams = urlSegments.params;
    let separator = urlParams.length ? '&' : '?';
    // for-of has a big polyfill.
    // tslint:disable-next-line:ban-iterable-foreach
    params.forEach((value, key) => {
        const values = value instanceof Array ? value : [value];
        for (let i = 0; i < values.length; i++) {
            const v = values[i];
            if (v === null || v === undefined) {
                continue;
            }
            urlParams +=
                separator +
                    encodeURIComponent(key) +
                    '=' +
                    encodeURIComponent(String(v));
            separator = '&';
        }
    });
    return (0, resource_url_impl_js_1.createResourceUrlInternal)(urlSegments.path + urlParams + urlSegments.hash);
}
exports.appendParams = appendParams;
const BEFORE_FRAGMENT_REGEXP = /[^#]*/;
/**
 * Creates a new TrustedResourceUrl based on an existing one but with the
 * addition of a fragment (the part after `#`). If the URL already has a
 * fragment, it is replaced with the new one.
 * @param fragment The fragment to add to the URL, verbatim, without the leading
 * `#`. No additional escaping is applied.
 */
function replaceFragment(trustedUrl, fragment) {
    const urlString = (0, resource_url_impl_js_1.unwrapResourceUrl)(trustedUrl).toString();
    return (0, resource_url_impl_js_1.createResourceUrlInternal)(BEFORE_FRAGMENT_REGEXP.exec(urlString)[0] + '#' + fragment);
}
exports.replaceFragment = replaceFragment;
/**
 * Creates a new TrustedResourceUrl based on an existing one with a single
 * subpath segment added to the end of the existing path and prior to any query
 * parameters and/or fragments that already exist in the URL.
 * @param pathSegment The singular sub path being added to the URL. Do not pass
 *     a pre-encoded value as this will result in it being double encoded.
 */
function appendPathSegment(trustedUrl, pathSegment) {
    const urlSegments = getUrlSegments((0, resource_url_impl_js_1.unwrapResourceUrl)(trustedUrl).toString());
    const separator = urlSegments.path.slice(-1) === '/' ? '' : '/';
    const newPath = urlSegments.path + separator + encodeURIComponent(pathSegment);
    return (0, resource_url_impl_js_1.createResourceUrlInternal)(newPath + urlSegments.params + urlSegments.hash);
}
exports.appendPathSegment = appendPathSegment;
/**
 * Creates a `TrustedResourceUrl` by generating a `Blob` from a
 * `SafeScript` and then calling `URL.createObjectURL` with that `Blob`.
 *
 * Caller must call `URL.revokeObjectURL()` on the stringified url to
 * release the underlying `Blob`.
 */
function objectUrlFromScript(safeScript) {
    const scriptContent = (0, script_impl_js_1.unwrapScript)(safeScript).toString();
    const blob = new Blob([scriptContent], { type: 'text/javascript' });
    return (0, resource_url_impl_js_1.createResourceUrlInternal)(URL.createObjectURL(blob));
}
exports.objectUrlFromScript = objectUrlFromScript;
/**
 * A function to safely retrieve the base URI from the Window object and set it
 * at the beginning of a given path-relative (starts with "/") resource url.
 *
 * @param pathRelativeUrl The resource to which the origin shall be prepended.
 */
function toAbsoluteResourceUrl(pathRelativeUrl) {
    const originalUrl = (0, resource_url_impl_js_1.unwrapResourceUrl)(pathRelativeUrl).toString();
    const qualifiedUrl = new URL(originalUrl, window.document.baseURI);
    return (0, resource_url_impl_js_1.createResourceUrlInternal)(qualifiedUrl.toString());
}
exports.toAbsoluteResourceUrl = toAbsoluteResourceUrl;
