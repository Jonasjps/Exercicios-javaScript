"use strict";
/**
 * @license
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.nodeToHtml = exports.nodeToHtmlInternal = exports.doctypeHtml = exports.joinHtmls = exports.concatHtmls = exports.scriptUrlToHtml = exports.scriptToHtml = exports.htmlEscape = void 0;
const html_impl_js_1 = require("../internals/html_impl.js");
const resource_url_impl_js_1 = require("../internals/resource_url_impl.js");
const script_impl_js_1 = require("../internals/script_impl.js");
/**
 * Returns HTML-escaped text as a `SafeHtml` object. No-op if value is already a
 * SafeHtml instance.
 *
 * Available options:
 * - `preserveSpaces` turns every second consecutive space character into its
 * HTML entity representation (`&#160;`).
 * - `preserveNewlines` turns newline characters into breaks (`<br>`).
 * - `preserveTabs` wraps tab characters in a span with style=white-space:pre.
 */
function htmlEscape(value, options = {}) {
    if ((0, html_impl_js_1.isHtml)(value)) {
        return value;
    }
    let htmlEscapedString = htmlEscapeToString(String(value));
    if (options.preserveSpaces) {
        // Do this first to ensure we preserve spaces after newlines and tabs.
        htmlEscapedString = htmlEscapedString.replace(/(^|[\r\n\t ]) /g, '$1&#160;');
    }
    if (options.preserveNewlines) {
        htmlEscapedString = htmlEscapedString.replace(/(\r\n|\n|\r)/g, '<br>');
    }
    if (options.preserveTabs) {
        htmlEscapedString = htmlEscapedString.replace(/(\t+)/g, '<span style="white-space:pre">$1</span>');
    }
    return (0, html_impl_js_1.createHtmlInternal)(htmlEscapedString);
}
exports.htmlEscape = htmlEscape;
/**
 * Creates a `SafeHtml` representing a script tag with inline script content.
 */
function scriptToHtml(script, options = {}) {
    const unwrappedScript = (0, script_impl_js_1.unwrapScript)(script).toString();
    let stringTag = `<script`;
    if (options.id) {
        stringTag += ` id="${htmlEscapeToString(options.id)}"`;
    }
    if (options.nonce) {
        stringTag += ` nonce="${htmlEscapeToString(options.nonce)}"`;
    }
    if (options.type) {
        stringTag += ` type="${htmlEscapeToString(options.type)}"`;
    }
    if (options.defer) {
        stringTag += ` defer`;
    }
    stringTag += `>${unwrappedScript}\u003C/script>`;
    return (0, html_impl_js_1.createHtmlInternal)(stringTag);
}
exports.scriptToHtml = scriptToHtml;
/**
 * Creates a `SafeHtml` representing a script tag with the src attribute.
 * This also supports CSP nonces and async loading.
 */
function scriptUrlToHtml(src, options = {}) {
    const unwrappedSrc = (0, resource_url_impl_js_1.unwrapResourceUrl)(src).toString();
    let stringTag = `<script src="${htmlEscapeToString(unwrappedSrc)}"`;
    if (options.async) {
        stringTag += ' async';
    }
    if (options.customElement) {
        stringTag += ` custom-element="${htmlEscapeToString(options.customElement)}"`;
    }
    if (options.defer) {
        stringTag += ` defer`;
    }
    if (options.id) {
        stringTag += ` id="${htmlEscapeToString(options.id)}"`;
    }
    if (options.nonce) {
        stringTag += ` nonce="${htmlEscapeToString(options.nonce)}"`;
    }
    if (options.type) {
        stringTag += ` type="${htmlEscapeToString(options.type)}"`;
    }
    if (options.crossorigin) {
        stringTag += ` crossorigin="${htmlEscapeToString(options.crossorigin)}"`;
    }
    stringTag += '>\u003C/script>';
    return (0, html_impl_js_1.createHtmlInternal)(stringTag);
}
exports.scriptUrlToHtml = scriptUrlToHtml;
/**
 * HTML-escapes the given text (`&`, `<`, `>`, `"` and `'`).
 */
function htmlEscapeToString(text) {
    const escaped = text
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&apos;');
    return escaped;
}
/** Creates a `SafeHtml` value by concatenating multiple `SafeHtml`s. */
function concatHtmls(htmls) {
    return joinHtmls('', htmls);
}
exports.concatHtmls = concatHtmls;
/**
 * Creates a `SafeHtml` value by concatenating multiple `SafeHtml`s interleaved
 * with a separator.
 */
function joinHtmls(separator, htmls) {
    const separatorHtml = htmlEscape(separator);
    return (0, html_impl_js_1.createHtmlInternal)(htmls
        .map((value) => (0, html_impl_js_1.unwrapHtml)(htmlEscape(value)))
        .join((0, html_impl_js_1.unwrapHtml)(separatorHtml).toString()));
}
exports.joinHtmls = joinHtmls;
/**
 * Returns a `SafeHtml` that contains `<!DOCTYPE html>`.
 * This is defined as a function to prevent the definition of a Trusted Type
 * policy when simply importing safevalues.
 */
function doctypeHtml() {
    return (0, html_impl_js_1.createHtmlInternal)('<!DOCTYPE html>');
}
exports.doctypeHtml = doctypeHtml;
/**
 * Non-exported version of `nodeToHtml`, with an explicit temporary root to
 * accomodate for the sanitizer's user case.
 */
function nodeToHtmlInternal(node, temporaryRoot) {
    temporaryRoot.appendChild(node);
    // XML serialization is preferred over HTML serialization as it is
    // stricter and makes sure all attributes are properly escaped, avoiding
    // cases where the tree might mutate when parsed again later due to the
    // complexities of the HTML parsing algorithm
    let serializedNewTree = new XMLSerializer().serializeToString(temporaryRoot);
    // We remove the outer most element as this is the span node created as
    // the root for the sanitized tree and contains a spurious xmlns attribute
    // from the XML serialization step.
    serializedNewTree = serializedNewTree.slice(serializedNewTree.indexOf('>') + 1, serializedNewTree.lastIndexOf('</'));
    return (0, html_impl_js_1.createHtmlInternal)(serializedNewTree);
}
exports.nodeToHtmlInternal = nodeToHtmlInternal;
/**
 * Serializes a Node into it's HTML representation.
 *
 * Note: this method uses strict XML serialization to mitigate mutation issues
 * when the html is then re-parsed by the browser.
 */
function nodeToHtml(node) {
    const tempRoot = document.createElement('span');
    return nodeToHtmlInternal(node, tempRoot);
}
exports.nodeToHtml = nodeToHtml;
